
#' Run one or more methods on simulated data.
#'
#' Given a \code{\link{Method}} object or list of \code{\link{Method}} objects,
#' this function runs the method(s) on the draws specified by \code{model_name}
#' and \code{index}.  The output of each method is saved to file.
#'
#' If parallel is not NULL, then it must be a list containing
#' \code{socket_names}, which can either be a positive integer specifying the
#' number of copies to run on localhost or else a character vector of machine
#' names (e.g., "mycluster-0-0").  The list \code{parallel} can can also contain
#' \code{libraries}, a character vector of R packages that will be needed on the
#' slaves.
#'
#' @export
#' @param my_methods a list of \code{\link{Method}} objects or a single
#'        \code{\link{Method}} object
#' @param dir the directory where \code{\link{Model}} object was saved (by
#'        \code{\link{generate_model}})
#' @param model_name the \code{\link{Model}} object's \code{name} attribute
#' @param index the index of a computed \code{\link{Draws}} object.  Can
#'        alternately be a vector of such indices.
#' @param out_loc (optional) a character vector that gives location (relative
#'        to model's path) that method outputs are stored.  This can be useful
#'        for staying organized when multiple simulations are based on the same
#'        Model and Draws objects.
#' @param parallel either \code{NULL} or a list containing \code{socket_names}
#'        and (optionally) \code{libraries}  (see Details for more information)
#' @seealso \code{\link{generate_model}} \code{\link{simulate_from_model}}
#' @examples
#' \dontrun{
#'  generate_model(make_my_model, dir = ".")
#'  simulate_from_model(model_name = "fm", nsim = 50, index = 1:2)
#'  run_method(list(my_method, their_method), model_name = "fm", 1:2)
#'  }
run_method <- function(my_methods, dir = ".", model_name, index,
                       out_loc = "out", parallel = NULL) {
  # make sure my_methods is a list of Method objects
  if (class(my_methods) == "list") {
    stopifnot(all(unlist(lapply(my_methods, function(m) class(m) == "Method"))))
  } else {
    stopifnot(class(my_methods) == "Method")
    my_methods <- list(my_methods)
  }
  # load model
  md <- get_model_dir_and_file(dir, model_name)
  model <- load_model(dir, model_name, more_info = FALSE)
  # prepare output directory
  out_dir <- file.path(md$dir, remove_slash(out_loc))
  if (!file.exists(out_dir)) dir.create(out_dir)
  # now run methods on each index
  index <- sort(index)
  nmethods <- length(my_methods)
  out_files <- list()
  if (is.null(parallel) || nmethods * length(index) == 1) {
    # run sequentially
    ii <- 1
    for (m in seq(nmethods)) {
      for (i in seq(length(index))) {
        out_files[[ii]] <- run_method_single(my_methods[[m]], model, dir,
                                           model_name, index[i], out_dir)
        ii <- ii + 1
      }
    }
  } else {
    # run in parallel
    check_parallel_list(parallel)
    out_files <- run_method_parallel(my_methods,  model, dir, model_name,
                                     index, out_dir,
                                     socket_names = parallel$socket_names,
                                     libraries = parallel$libraries)
  }
  invisible(out_files)
}

#' Run one or more methods on simulated data.
#'
#' This is an internal function.  Users should call the wrapper function.
#' \code{\link{run_method}}. Here "single" refers to a single index
#' and a single method.
#'
#' @param method a \code{\link{Method}} object
#' @param model a \code{\link{Model}} object
#' @param draws a \code{\link{Draws}} object generated by \code{model}
#' @param dir the directory where \code{\link{Model}} object was saved (by
#'        \code{\link{generate_model}})
#' @param model_name the \code{\link{Model}} object's \code{name} attribute
#' @param out_loc (optional) a character vector that gives location (relative
#'        to model's path) that method outputs are stored.  This can be useful
#'        for staying organized when multiple simulations are based on the same
#'        Model and Draws objects.
run_method_single <- function(method, model, dir, model_name, index,
                       out_dir) {
  draws <- load_draws(dir, model_name, index, more_info = FALSE)
  out <- list()
  for (rid in names(draws@draws)) {
    out[[rid]] <- list()
    time <- system.time({temp <- method@method(model, draws@draws[[rid]])})
    if (class(temp) != "list") temp <- list(out = temp)
    out[[rid]] <- temp
    out[[rid]]$time <- time
  }
  out_file <- sprintf("%s/r%s_m%s.Rdata", out_dir, index, method@name)
  output <- new("Output",
                model_name = model_name,
                index = index,
                method_name = method@name,
                method_label = method@label,
                out = out)
  info <- list(method = method, date_generated = date())
  save(output, info, file = out_file)
  catsim("..Performed", method@label, "on ", draws@label, "and saved to",
      out_file, fill = TRUE)
  invisible(out_file)
}

#' Load one or more output objects from file.
#'
#' After \code{\link{run_method}} has been called, this function can
#' be used to load one or more of the saved \code{\link{Output}} object(s).
#' If multiple indices are provided, these will be combined
#' into a new single \code{\link{Output}} object.
#'
#' @export
#' @param dir the directory passed to \code{\link{generate_model}})
#' @param model_name the \code{\link{Model}} object's \code{name}
#' @param index a vector of positive integers.
#' @param method_name the \code{\link{Method}} object's \code{name}
#' @param out_names a character vector of which elements of output should be
#'        loaded. If NULL, then all elements are loaded.
#' @param out_loc Only needed if it was used in call to
#'        \code{\link{run_method}}.
#' @seealso \code{\link{run_method}} \code{\link{load_model}} \code{\link{load_draws}}
#' @examples
#' \dontrun{
#' }
load_outputs <- function(dir, model_name, index, method_name,
                         out_names = NULL, out_loc = "out") {
  md <- get_model_dir_and_file(dir, model_name)
  if (any(table(index) > 1)) stop("index cannot have repeats.")
  index <- sort(index)
  out_dir <- file.path(md$dir, remove_slash(out_loc))
  output_files <- sprintf("%s/r%s_m%s.Rdata", out_dir, index, method_name)
  if (length(index) == 1) {
    tryCatch(load(output_files),
             warning=function(w)
               stop(sprintf("Could not find output file at %s.",
                            output_files)))
    if (!is.null(out_names))
      output <- subset_output(output, out_names)
    return(output)
  }
  newout <- list()
  for (i in seq_along(index)) {
    tryCatch(load(output_files[i]),
             warning=function(w)
               stop(sprintf("Could not find output file at %s.",
                            output_files[i])))
    if (!is.null(out_names)) {
      output <- subset_output(output, out_names)
    }
    newout <- c(newout, output@out)
  }
  draws <- new("Output", model_name = model_name, index = index,
               method_name = method_name, method_label = output@method_label,
               out = newout)
  return(draws)
}

subset_output <- function(output, out_names) {
  for (j in seq(length(output@out))) {
    if (!(all(out_names %in% names(output@out[[j]]))))
      stop("Element ", names(output@out)[j], " does not match out_names.")
    output@out[[j]] <- output@out[[j]][out_names]
  }
  output
}
